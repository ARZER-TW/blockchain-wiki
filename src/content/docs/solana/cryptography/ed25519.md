---
title: "Ed25519"
description: "Edwards-curve Digital Signature Algorithm on Curve25519"
tags: [solana, cryptography, digital-signature, ed25519, elliptic-curve]
---

# Ed25519

## 概述

Ed25519 是 Solana 的核心簽章演算法，基於 Twisted Edwards 曲線 Curve25519 的 [數位簽章](/fundamentals/cryptography/digital-signature-overview/) 方案。它屬於 Schnorr-type 簽名家族，由 Daniel J. Bernstein 等人在 2011 年提出。與 Ethereum 使用的 [ECDSA](/fundamentals/cryptography/ecdsa/) 相比，Ed25519 具有確定性 nonce（消除 $k$-reuse 攻擊風險）、更緊湊的簽名（64 bytes）與公鑰（32 bytes），以及更快的批量驗證能力。Solana 選擇 Ed25519 作為帳戶體系的基礎——公鑰直接作為帳戶地址。

## 核心原理

### Twisted Edwards Curve

Ed25519 使用的 Curve25519 定義在 Twisted Edwards 形式上：

$$-x^2 + y^2 = 1 + d \cdot x^2 y^2$$

其中 $d = -121665/121666$，定義在有限域 $\mathbb{F}_p$ 上，$p = 2^{255} - 19$。

基點 $B$ 的階為 $\ell$（一個 253-bit 的質數）：

$$\ell = 2^{252} + 27742317777372353535851937790883648493$$

群的 cofactor $h = 8$，即群的總階為 $8\ell$。

### 金鑰生成

1. 隨機選取 32-byte 種子 $\text{seed}$
2. 計算 $H(\text{seed})$ = SHA-512，得到 64 bytes
3. 取前 32 bytes，clamp 處理得到標量 $a$：
   - 清除最低 3 bits（確保是 8 的倍數，處理 cofactor）
   - 設定第 254 bit = 1，清除第 255 bit
4. 公鑰 $A = a \cdot B$（壓縮為 32 bytes，使用 $y$ 座標 + $x$ 的符號位）

後 32 bytes 保留作為簽名時的 nonce 生成材料。

### 簽名（Sign）

Ed25519 的簽名是確定性的——不需要隨機數生成器：

1. 計算 $r = H(\text{prefix} \| m)$，其中 $\text{prefix}$ 是金鑰雜湊的後 32 bytes
2. 計算 $R = r \cdot B$
3. 計算 $S = r + H(R \| A \| m) \cdot a \pmod{\ell}$
4. 簽名為 $(R, S)$，共 64 bytes

$$\sigma = (R, S) \quad \text{where} \quad S = r + H(R \| A \| m) \cdot a$$

確定性 nonce 的關鍵：$r$ 由訊息和私鑰衍生，不依賴外部隨機數。即使 RNG 有缺陷，簽名仍然安全。這與 [ECDSA](/fundamentals/cryptography/ecdsa/) 形成鮮明對比——ECDSA 的 $k$-reuse 直接洩露私鑰。

### 驗證（Verify）

驗證等式：

$$8 \cdot S \cdot B = 8 \cdot R + 8 \cdot H(R \| A \| m) \cdot A$$

乘以 cofactor 8 是為了確保安全性不受小子群攻擊影響。

### Cofactor 處理

Ed25519 的群有 cofactor $h = 8$，代表存在 8 個 order 為 1, 2, 4 或 8 的「小子群」點。不同實作對 cofactor 的處理方式不同：

- **Ed25519（原始）**：驗證時乘以 cofactor，即 $8SB = 8R + 8H(R \| A \| m) \cdot A$
- **Ed25519ctx / Ed25519ph**：RFC 8032 定義的變體，支援 context string 和 pre-hashing
- **Ristretto255**：透過群商（quotient group）消除 cofactor 問題，確保唯一的點表示

Solana 使用標準 Ed25519，驗證時乘以 cofactor。

### 批量驗證（Batch Verification）

Ed25519 支援高效的批量驗證。給定 $n$ 組 $(R_i, S_i, A_i, m_i)$，選取隨機標量 $z_i$，檢查：

$$\sum_{i=1}^{n} z_i \cdot (8S_iB - 8R_i - 8H(R_i \| A_i \| m_i) \cdot A_i) = \mathcal{O}$$

批量驗證的效率顯著高於逐一驗證，因為多個標量乘法可以合併。Solana 的 runtime 利用此特性在區塊驗證時批量處理交易簽名。

### 與 ECDSA/secp256k1 的比較

| 性質 | Ed25519 (Solana) | [ECDSA/secp256k1](/ethereum/cryptography/ecdsa/) (Ethereum) |
|------|-----------------|---------------------------------------------|
| 曲線 | Twisted Edwards (Curve25519) | Weierstrass ([secp256k1](/fundamentals/cryptography/secp256k1/)) |
| 簽名大小 | 64 bytes | 65 bytes ($r$, $s$, $v$) |
| 公鑰大小 | 32 bytes（壓縮） | 33 bytes（壓縮）/ 65 bytes（未壓縮） |
| Nonce | 確定性（SHA-512 衍生） | 隨機或 RFC 6979 |
| 批量驗證 | 原生支援 | 有限 |
| 公鑰恢復 | 不支援 | 支援（ecrecover） |
| Cofactor | $h = 8$ | $h = 1$ |

Ed25519 不支援公鑰恢復（ecrecover），因此 Solana 的交易必須明確附帶簽名者的公鑰。

## 程式碼範例

### TypeScript（@solana/web3.js）

```typescript
import { Keypair } from '@solana/web3.js';
import nacl from 'tweetnacl';

// Ed25519 金鑰生成
const keypair = Keypair.generate();
console.log('Public key (32 bytes):', keypair.publicKey.toBase58());
console.log('Secret key (64 bytes):', keypair.secretKey.length);
// secretKey 前 32 bytes 是種子，後 32 bytes 是公鑰

// 簽名（確定性）
const message = Buffer.from('Hello Solana');
const signature = nacl.sign.detached(message, keypair.secretKey);
console.log('Signature (64 bytes):', signature.length);

// 驗證
const isValid = nacl.sign.detached.verify(
  message,
  signature,
  keypair.publicKey.toBytes()
);
console.log('Valid:', isValid);

// 確定性驗證：同一訊息產生同一簽名
const sig2 = nacl.sign.detached(message, keypair.secretKey);
console.log('Deterministic:', Buffer.from(signature).equals(Buffer.from(sig2)));

// 從 seed 恢復 keypair
const seed = keypair.secretKey.slice(0, 32);
const restored = Keypair.fromSeed(seed);
console.log('Same pubkey:', keypair.publicKey.equals(restored.publicKey));
```

### Rust（ed25519-dalek）

```rust
use ed25519_dalek::{SigningKey, Signature, Verifier};
use rand::rngs::OsRng;

// 金鑰生成
let signing_key = SigningKey::generate(&mut OsRng);
let verifying_key = signing_key.verifying_key();
println!("Public key: {:?}", verifying_key.as_bytes());

// 簽名
let message = b"Hello Solana";
let signature: Signature = signing_key.sign(message);
println!("Signature: {} bytes", signature.to_bytes().len());

// 驗證
assert!(verifying_key.verify(message, &signature).is_ok());

// 批量驗證
let messages: Vec<&[u8]> = vec![b"msg1", b"msg2", b"msg3"];
let keys: Vec<SigningKey> = (0..3)
    .map(|_| SigningKey::generate(&mut OsRng))
    .collect();
let signatures: Vec<Signature> = keys.iter()
    .zip(messages.iter())
    .map(|(k, m)| k.sign(m))
    .collect();
let verifying_keys: Vec<_> = keys.iter()
    .map(|k| k.verifying_key())
    .collect();

// 批量驗證效率更高
let result = ed25519_dalek::verify_batch(
    &messages, &signatures, &verifying_keys
);
assert!(result.is_ok());
```

## 相關概念

- [數位簽章概述](/fundamentals/cryptography/digital-signature-overview/) - 數位簽章的通用概念與安全性質
- [橢圓曲線密碼學](/fundamentals/cryptography/elliptic-curve-cryptography/) - Ed25519 底層的橢圓曲線數學
- [Ed25519 Precompile](/solana/cryptography/ed25519-precompile/) - Solana 鏈上驗證 Ed25519 簽名的原生程式
- [ECDSA](/fundamentals/cryptography/ecdsa/) - 另一種橢圓曲線簽章方案（Ethereum 使用）
- [ECDSA (Ethereum)](/ethereum/cryptography/ecdsa/) - Ethereum 上的 ECDSA 實作細節
- [secp256k1](/fundamentals/cryptography/secp256k1/) - Ethereum ECDSA 使用的曲線
- [公鑰密碼學](/fundamentals/cryptography/public-key-cryptography/) - 非對稱密碼學的通用概念
- [Solana 地址推導](/solana/account-model/address-derivation-solana/) - Ed25519 公鑰如何成為帳戶地址
- [PDA](/solana/account-model/pda/) - 離開 Ed25519 曲線的程式衍生地址
- [Schnorr Signatures (Bitcoin)](/bitcoin/cryptography/schnorr-signatures/) - 同屬 Schnorr-type 家族的 Bitcoin 簽章方案

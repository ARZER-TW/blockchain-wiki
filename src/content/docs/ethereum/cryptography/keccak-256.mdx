---
title: "Keccak-256"
description: "Keccak256, Keccak, ETH Hash"
tags: [ethereum, cryptography, hash-function, keccak]
sidebar:
  order: 2
---

import EthBuildEmbed from '../../../../components/EthBuildEmbed'

# Keccak-256 在 Ethereum 中的應用

> 本文聚焦 Ethereum 特定的實現細節。通用理論請參見 [Keccak-256 雜湊函數](/fundamentals/cryptography/keccak-256/)。

## eth.build

透過 eth.build 操作 Hash Function 節點，輸入任意文字觀察即時產生的 Keccak-256 雜湊值，體驗雜湊函數的核心特性：任何微小的輸入變化都會產生完全不同的輸出。

<EthBuildEmbed
  client:load
  src="https://sandbox.eth.build/wofCrGxhc3Rfbm9kZV9pZCLEgcSDxIVsaW5rxItkFsKlxIfEiXPClMKKwqLEjCDCpHR5cGXCqklucHV0L1RleHTCo3Bvc8KSWsOMwqDCpHNpemXCksONASwywqVmxIJnc8KAwqVvcsSJcgDCpG3EiGUAwqbEk8SqdHPCkcKDwqRuYW1lxLnEo8SlxY_EksSUw4DCp2_Eq8WXxZnFm8WdxZ_FocSkZcKmxIRyxJNnwqXFpWvFmRXCqnByb8SlcnRpZXPChMKrYmxvY2vGhFPEvGUywqtwxIJjZWhvbMWNwq9lbnRlciDGn8SwIGjGoGXCpcaDdGxlwqTErsSwwqV2YWx1xq3Gn8SExJ7EjB_EosWxwqtDcsSkdG8vSMSDaMSyxLTEvwHDjMS4xLrGkMKSeB7FhMWGxYjFisWMxqACxZDFksWUxZbEq8WsxZzFnsaox510xrzEpcKtxbTFtixudW1ixqDCpMW5FcWoxarHnsWax6DFn8KkaMeGx6XFsseobsW3xbnFmRbFvcW_xoHGg8aFwoDCicSfZCHHvMKtRGlzxpRheS9XYXRjx4fEs8S1w40CwqjDjMKWx47EvcS_AzE8x5NhxYfFicWLxY0Dx5rEicecxKnHtcKEx7fFoMe8xaTEk2vEmMSCx65swqDIhMaAxqDIh8WIwojIiyLIjsiQyJLEgsiVVGnGq2XHiMS1FCjIo8S-xYDDtADIqcirx5bFjQHIsMWTyYHIhsaEc8KFwqhmb8aexo_EvSzGiMaKxozGjsaQxpLIk8aWxpjGmsagwqDGqcmPxqzCpcmOyZDGscazxrXCrceFc2ggRnVuY8aDyanFuMi6xLXClhUgAB8Ax6d0xbXHv8eqx6zHrnLClhbKlSEAxZRnxb91cHPCkMKmY8mpZmlnwoDCp3bGoMS7yanDij7HjMON"
  title="Hash Function (Keccak-256)"
  height={500}
/>

## 概述

Keccak-256 是 Ethereum 的核心雜湊函數，用於地址推導、交易 ID、狀態樹等幾乎所有鏈上運算。EVM 中的 `KECCAK256` opcode（歷史上誤稱為 `SHA3`）實際上執行的是原始 Keccak-256，而非 NIST SHA-3。關於兩者的差異，請參見[通用理論](/fundamentals/cryptography/keccak-256/)中的填充規則章節。

## EVM 層

### KECCAK256 Opcode

- **Opcode**：`0x20`（歷史上名為 `SHA3`，但實際是 Keccak-256）
- **Gas 費用**：$30 + 6 \times \lceil \text{len}/32 \rceil$
- 這是 EVM 中唯一的原生 hash opcode

### 地址推導

```
address = keccak256(public_key)[12:]
```

取 uncompressed public key（64 bytes，去掉 `0x04` prefix）的 Keccak-256 雜湊，再取後 20 bytes。詳見 [地址推導](/ethereum/accounts/address-derivation/)。

### Storage Slot 計算

Solidity mapping 的 storage layout 依賴 Keccak-256：

```
mapping slot = keccak256(key . slot_number)
```

其中 `.` 是 concatenation，`key` 和 `slot_number` 各佔 32 bytes。

### CREATE2 地址

確定性合約部署的地址計算：

```
address = keccak256(0xff . deployer . salt . keccak256(bytecode))[12:]
```

## 資料結構

- [Merkle Patricia Trie](/ethereum/data-structures/merkle-patricia-trie/)：節點雜湊使用 Keccak-256
- [State Trie](/ethereum/data-structures/state-trie/)、[Storage Trie](/ethereum/data-structures/storage-trie/)、[Transaction Trie](/ethereum/data-structures/transaction-trie/)、[Receipt Trie](/ethereum/data-structures/receipt-trie/)：全部基於 Keccak-256
- [RLP 編碼](/ethereum/data-structures/rlp-encoding/)：編碼後再 Keccak-256 得到雜湊

## Solidity 應用

### 函數選擇器

```solidity
// 取 keccak256 的前 4 bytes
bytes4 selector = bytes4(keccak256("transfer(address,uint256)"));
// = 0xa9059cbb
```

### Event Topic

```solidity
// Event signature 的 keccak256 作為 topic[0]
bytes32 topic = keccak256("Transfer(address,address,uint256)");
```

### 常見 Solidity 用法

```solidity
// 結構化資料雜湊（EIP-712 相關）
bytes32 hash = keccak256(abi.encodePacked(a, b, c));

// 更安全的寫法（避免 collision）
bytes32 hash = keccak256(abi.encode(a, b, c));
```

## 程式碼範例

```python
from Crypto.Hash import keccak

def keccak256(data: bytes) -> bytes:
    """計算 Keccak-256 雜湊"""
    h = keccak.new(digest_bits=256)
    h.update(data)
    return h.digest()

# Ethereum 地址推導（從 uncompressed public key）
# 公鑰是 64 bytes（去掉 0x04 prefix 後）
dummy_pubkey = bytes.fromhex(
    "04"  # uncompressed prefix（推導時去掉）
    "7e5f4552091a69125d5dfcb7b8c2659029395bdf"
    "b7e5f4552091a69125d5dfcb7b8c2659029395bd"
    "f7e5f4552091a69125d5dfcb7b8c265902939500"
    "117e5f4552091a69125d5dfcb7b8c26590293955"
)
pubkey_bytes = dummy_pubkey[1:]
address = keccak256(pubkey_bytes)[-20:]
print(f"Address: 0x{address.hex()}")

# Solidity function selector
sig = b"transfer(address,uint256)"
selector = keccak256(sig)[:4]
print(f"Function selector: 0x{selector.hex()}")
```

```javascript
import { keccak256, toUtf8Bytes } from 'ethers';

// 計算 function selector
const sig = 'transfer(address,uint256)';
const hash = keccak256(toUtf8Bytes(sig));
const selector = hash.slice(0, 10); // 0x + 4 bytes
console.log(`selector: ${selector}`); // 0xa9059cbb

// 計算 event topic
const eventSig = 'Transfer(address,address,uint256)';
const topic = keccak256(toUtf8Bytes(eventSig));
console.log(`topic: ${topic}`);
```

## 相關概念

- [Keccak-256 通用理論](/fundamentals/cryptography/keccak-256/) - Sponge construction、安全性分析
- [雜湊函數概述](/fundamentals/cryptography/hash-function-overview/) - 雜湊函數的通用安全性質
- [SHA-256](/ethereum/cryptography/sha-256/) - 另一種雜湊函數，用於 Beacon Chain
- [地址推導](/ethereum/accounts/address-derivation/) - 從公鑰到 Ethereum 地址的流程
- [Merkle Patricia Trie](/ethereum/data-structures/merkle-patricia-trie/) - 以 Keccak-256 為基礎的狀態樹
- [RLP 編碼](/ethereum/data-structures/rlp-encoding/) - 資料序列化後再做 Keccak-256
- [ABI 編碼](/ethereum/data-structures/abi-encoding/) - 函數選擇器的計算依賴 Keccak-256
- [EIP-55 地址校驗](/ethereum/accounts/eip-55/) - 使用 Keccak-256 實現混合大小寫校驗

---
title: "SHA-256 雜湊函數"
description: "SHA-256 hash function: Merkle-Damgard construction, compression function, message schedule, security properties"
tags: [fundamentals, cryptography, hash-function, sha256, merkle-damgard]
---

# SHA-256

## 概述

SHA-256（Secure Hash Algorithm 256-bit）是 SHA-2 家族的成員，由 NSA 設計、NIST 標準化（FIPS 180-4）。SHA-256 是目前最廣泛部署的密碼學雜湊函數之一，被 Bitcoin、TLS、數位簽章等眾多系統採用。它基於 Merkle-Damgard 迭代結構，輸出固定的 256-bit 雜湊值。

## Merkle-Damgard 結構

SHA-256 採用 Merkle-Damgard 迭代結構：

1. **填充**：訊息末尾加 `1` bit，再加 $0$ bits 使總長度 $\equiv 448 \pmod{512}$，最後附 64-bit 原始訊息長度
2. **分區塊**：填充後的訊息切為 512-bit 區塊 $M_1, M_2, \ldots, M_N$
3. **壓縮**：從初始向量 $H_0$ 開始，逐區塊壓縮：$H_i = H_{i-1} + \text{Compress}(H_{i-1}, M_i)$

這種結構簡單高效，但有一個已知弱點：Length Extension Attack（見下方安全性章節）。

## 初始向量與常數

8 個 32-bit 初始向量，取自前 8 個質數之平方根的小數部分：

$$H_0^{(0)} = \texttt{6a09e667}, \quad H_1^{(0)} = \texttt{bb67ae85}, \quad \ldots$$

64 個輪常數 $K_t$，取自前 64 個質數之立方根的小數部分。這些常數的來源是確定性的（"nothing up my sleeve" numbers），確保設計中沒有隱藏的後門。

## 壓縮函數

每個 512-bit 區塊經過 64 輪運算。

### Message Schedule

將 16 個 32-bit word 擴展為 64 個：

$$W_t = \begin{cases} M_t & 0 \le t \le 15 \\ \sigma_1(W_{t-2}) + W_{t-7} + \sigma_0(W_{t-15}) + W_{t-16} & 16 \le t \le 63 \end{cases}$$

其中小 sigma 函數：

$$\sigma_0(x) = \text{ROTR}^7(x) \oplus \text{ROTR}^{18}(x) \oplus \text{SHR}^3(x)$$
$$\sigma_1(x) = \text{ROTR}^{17}(x) \oplus \text{ROTR}^{19}(x) \oplus \text{SHR}^{10}(x)$$

### 每輪更新

使用 8 個工作變數 $a$ 到 $h$：

$$T_1 = h + \Sigma_1(e) + \text{Ch}(e,f,g) + K_t + W_t$$
$$T_2 = \Sigma_0(a) + \text{Maj}(a,b,c)$$

其中：

$$\Sigma_0(a) = \text{ROTR}^2(a) \oplus \text{ROTR}^{13}(a) \oplus \text{ROTR}^{22}(a)$$
$$\Sigma_1(e) = \text{ROTR}^6(e) \oplus \text{ROTR}^{11}(e) \oplus \text{ROTR}^{25}(e)$$
$$\text{Ch}(e,f,g) = (e \land f) \oplus (\lnot e \land g)$$
$$\text{Maj}(a,b,c) = (a \land b) \oplus (a \land c) \oplus (b \land c)$$

每輪之後，工作變數向下移位：$h \leftarrow g, g \leftarrow f, \ldots, e \leftarrow d + T_1, \ldots, a \leftarrow T_1 + T_2$。

## 安全性

- 輸出：256 bit
- **Preimage resistance**：$O(2^{256})$
- **Collision resistance**：$O(2^{128})$
- **Length Extension Attack**：已知 $H(m)$ 和 $|m|$ 可偽造 $H(m \| \text{padding} \| m')$，無需知道 $m$

Length Extension Attack 是 Merkle-Damgard 結構的固有弱點。因為 $H(m)$ 就是壓縮函數處理完所有區塊後的內部狀態，攻擊者可以從這個狀態繼續壓縮新的區塊。對策包括：
- 使用 HMAC：$\text{HMAC}(K, m) = H((K \oplus \text{opad}) \| H((K \oplus \text{ipad}) \| m))$
- 改用 Sponge 結構的雜湊函數（如 [Keccak-256](/fundamentals/cryptography/keccak-256/)）

## 硬體加速

SHA-256 享有廣泛的硬體加速支援：
- **Intel SHA Extensions**：專用 CPU 指令（`sha256rnds2`, `sha256msg1`, `sha256msg2`）
- **ARM Crypto Extensions**：類似的 ARM 硬體加速
- **ASIC**：Bitcoin 挖礦推動了大量 SHA-256 ASIC 的開發

這使得 SHA-256 在需要高吞吐量的場景（如共識層）中特別有優勢。

## 程式碼範例

```python
import hashlib

# 基本 SHA-256
msg = b"hello"
h = hashlib.sha256(msg).hexdigest()
print(f"SHA-256('hello') = {h}")

# Double SHA-256（Bitcoin 使用）
def double_sha256(data: bytes) -> bytes:
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

print(f"Double SHA-256('bitcoin'): {double_sha256(b'bitcoin').hex()}")

# SHA-256 vs Keccak-256 比較
from Crypto.Hash import keccak

data = b"test"
sha256_result = hashlib.sha256(data).hexdigest()
k = keccak.new(digest_bits=256)
k.update(data)
keccak_result = k.hexdigest()

print(f"SHA-256:    {sha256_result}")
print(f"Keccak-256: {keccak_result}")
```

## 相關概念

- [雜湊函數概述](/fundamentals/cryptography/hash-function-overview/) - 雜湊函數的安全性質總覽
- [Keccak-256](/fundamentals/cryptography/keccak-256/) - 基於 Sponge 結構的替代雜湊函數
- [Merkle Tree](/fundamentals/data-structures/merkle-tree/) - SHA-256 是常用的雜湊函數選項
- [公鑰密碼學](/fundamentals/cryptography/public-key-cryptography/) - 雜湊函數在數位簽章中的應用
